package com.ysoft.security.odc.yocto;

import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.AnalysisPhase;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.exception.InitializationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class YoctoPatchedVulnerabilitySuppressionAnalyzer extends AbstractYoctoAnalyzer {

    private static final Logger LOGGER = LoggerFactory.getLogger(YoctoPatchedVulnerabilitySuppressionAnalyzer.class);

    @Override
    public String getName() {
        return "YOCTO suppression analyzer";
    }

    @Override
    protected void prepareFileTypeAnalyzer(Engine engine) throws InitializationException {}

    @Override
    public AnalysisPhase getAnalysisPhase() {
        return AnalysisPhase.POST_FINDING_ANALYSIS;
    }

    @Override
    protected void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
        try{
            final IpkFile ipkFile = parseIpkFile(dependency.getActualFile());
            final Set<String> remainingCvesForSuppression = new HashSet<>(ipkFile.getFixedCves());
            for (final Vulnerability vulnerability : new HashSet<>(dependency.getVulnerabilities())) { // For some reason, this API does not return a copy, which causes ConcurrentModificationException.
                final String vulnerabilityName = vulnerability.getName();
                if (remainingCvesForSuppression.contains(vulnerabilityName)) {
                    dependency.removeVulnerability(vulnerability);
                    dependency.addSuppressedVulnerability(vulnerability);
                    remainingCvesForSuppression.remove(vulnerabilityName);
                }
            }
            if(!remainingCvesForSuppression.isEmpty()){
                LOGGER.warn("Dependency {} has some undetected vulnerabilities to suppress that were not matched: {}", dependency.getActualFilePath(), remainingCvesForSuppression);
            }
        } catch (IOException e) {
            throw new AnalysisException(e);
        }
    }
}
